#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 8

#define saturate(x) clamp(x, 0.0, 1.0)

struct TriangleData {
	vec3 v1, v2, v3;
	vec4 v21, v32, v13;
	vec4 normal;
	vec3 t21, t32, t13;
};

struct TreeNode
{
	int leftNode;	// The index of the left node
	int rightNode;	// The index of the right node

	int axis;		// The axis for this node
	float split;	// The offset on this axis

	int primitiveCount;			// The size of this leaf
	int primitiveStartOffset;	// The offset where the triangles are
};

//struct TriangleData {
//	vec3 v1;
//	float pad1;
//	vec3 v2;
//	float pad2;
//	vec3 v3;
//	float pad3;
	
//	vec4 v21, v32, v13;
//	vec4 normal;
//	vec3 t21;
//	float pad4;
//	vec3 t32;
//	float pad5; 
//	vec3 t13;
//	float pad6;
//};

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = WORKGROUP_SIZE) in;

layout(set = 0, binding = 0, r32f) coherent uniform image3D MeshSDF;
layout(set = 1, binding = 0, rgba8) coherent uniform image3D VectorField;

layout(set = 2, binding = 0) buffer MeshTriangleArray {
	TriangleData data[];
};

layout(set = 2, binding = 1) uniform MeshTriangleAttributes
{
	int size;
};

layout(set = 2, binding = 2) buffer MeshIndexArray {
	TreeNode indexData[];
};

float dot2(vec3 v) {
	return dot(v, v);
}

float vmax(vec3 v) {
	return max(max(v.x, v.y), v.z);
}

float vmin(vec3 v) {
	return min(min(v.x, v.y), v.z);
}

float fBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// All SDFS from iq, http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
// But they are tweaked for their threejs equivalents
float sdSphere( vec3 p, float r )
{
	return length(p) - r;
}

float udBox(vec3 p, vec3 b)
{
	return length(max(abs(p) - b, 0.0));
}

float sdPlane( vec3 p)
{
	return p.y;
}

float sdCappedCylinder( vec3 p, vec2 h)
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float pow8(float x)
{
	x *= x; // xˆ2
	x *= x; // xˆ4
	return x * x;
}

// Reference: https://github.com/stackgl/glsl-smooth-min
float smin(float a, float b, float k) 
{
  float res = exp(-k * a) + exp(-k * b);
  return -log(res) / k;
}
float length8(vec2 v)
{
	return pow(pow8(v.x) + pow8(v.y), .125);
}
// float wheelDistance(Point3 X, Point3 C, float r, float R) {
// return length8(Vector2(length(X.xz - C.xz) - r, X.y - C.y)) - R;
// }

float sdTorus82( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length8(q)-t.y;
}

float sdTorus( vec3 p)
{
  vec2 q = vec2(length(p.xz)-1.0,p.y);
  return length(q) - .2;
}

float sdHexPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);
}

float udRoundBox( vec3 p, vec3 b, float r )
{
	return length(max(abs(p) - b, 0.0)) - r;
}

float sdCappedCone( in vec3 p)
{
	p.y -= .25;
    vec2 q = vec2( length(p.xz), p.y );
    vec2 v = vec2(0.5773502691896258, -0.5773502691896258);
    vec2 w = v - q;
    vec2 vv = vec2( dot(v,v), v.x*v.x );
    vec2 qv = vec2( dot(v,w), v.x*w.x );
    vec2 d = max(qv,0.0) * qv / vv;
    return sqrt(max(dot(w,w) - max(d.x,d.y), .000000001) ) * sign(max(q.y*v.x-q.x*v.y,w.y));
}

float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

float sdEllipsoid( in vec3 p, in vec3 r )
{
    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);
}

float opUnion( float d1, float d2 )
{
    return min(d1, d2);
}

vec3 opCheapBend( vec3 p, float magnitude)
{
    float c = cos(magnitude * p.y);
    float s = sin(magnitude * p.y);
    mat2  m = mat2(c, -s, s, c);
    vec3 q = vec3( m * p.xy, p.z);
    return q;
}

float repeatDimension(float x, float m, float extent)
{
	return mix(x, mod(x + m * .5, m) - m * .5, step(abs(x + m * .5), extent));
}

float minionBaseSDF(vec3 point)
{
	point.y += .5;
	point *= 4.0;
	vec3 blendOffset = vec3(0.0, 1.5, 0.0);
	vec3 bendedPoint = opCheapBend(point - blendOffset, .15) + blendOffset;
	vec3 bendedPointSym = opCheapBend(point - blendOffset, -.15) + blendOffset;

	float base = sdCapsule(point, vec3(0.0, .5, .0), vec3(0.0, 3.5, 0.0), 1.15);

	float hand1 = sdCapsule(bendedPoint, vec3(1.15, 1.25, 0.0), vec3(2.25, .5, 0.0), .135);
	float hand2 = sdCapsule(bendedPointSym, vec3(-1.15, 1.25, 0.0), vec3(-2.25, .5, 0.0), .135);

	float foot1 = sdCapsule(point, vec3(0.45, -1.0, 0.0), vec3(0.35, 0.5, 0.0), .2);
	float foot2 = sdCapsule(point, vec3(-0.45, -1.0, 0.0), vec3(-0.35, 0.5, 0.0), .2);

	float dist = smin(base, hand1, 5.0);
	dist = smin(dist, hand2, 5.0);
	dist = smin(dist, foot1, 5.0);
	dist = smin(dist, foot2, 5.0);

	// Left Hand
	bendedPointSym.y -= .15;
	float handBase1 = sdCappedCylinder(bendedPointSym - vec3(1.6, -.45, 0.0), vec2(.2, .05));
	handBase1 = smin(handBase1, sdCappedCylinder(bendedPointSym - vec3(1.6, -.6, 0.0), vec2(.1, .15)), 7.5);

	// Base
	handBase1 = smin(handBase1, sdSphere(bendedPointSym - vec3(1.6, -.8, 0.0), .15), 10.0);

	// Fingers (note: cylinders would make it better.. but no time!)
	handBase1 = smin(handBase1, sdSphere(bendedPointSym - vec3(1.3, -1.0, -0.1), .135), 20.0);
	handBase1 = smin(handBase1, sdSphere(bendedPointSym - vec3(1.85, -1.0, -0.1), .135), 20.0);
	handBase1 = smin(handBase1, sdSphere(bendedPointSym - vec3(1.6, -1.15, -.05), .135), 20.0);

	dist = min(dist, handBase1);

	// Right Hand
	bendedPoint.y -= .15;
	float handBase2 = sdCappedCylinder(bendedPoint - vec3(-1.6, -.45, 0.0), vec2(.2, .05));
	handBase2 = smin(handBase2, sdCappedCylinder(bendedPoint - vec3(-1.6, -.6, 0.0), vec2(.1, .15)), 7.5);

	// Base
	handBase2 = smin(handBase2, sdSphere(bendedPoint - vec3(-1.6, -.8, 0.0), .15), 10.0);

	// Fingers
	handBase2 = smin(handBase2, sdSphere(bendedPoint - vec3(-1.3, -1.0, -0.1), .135), 20.0);
	handBase2 = smin(handBase2, sdSphere(bendedPoint - vec3(-1.85, -1.0, -0.1), .135), 20.0);
	handBase2 = smin(handBase2, sdSphere(bendedPoint - vec3(-1.6, -1.15, -.05), .135), 20.0);

	dist = min(dist, handBase2);

	vec3 glassPoint = point - vec3(0.0, 3.0, 1.15);	
	float glassBase = sdTorus82(glassPoint.xzy, vec2(.5, .1));

	float belt = sdTorus82(point - vec3(0.0, 3.0, 0.0), vec2(1.1, .125));
	belt = max(belt, -sdSphere(glassPoint, .5));
	glassBase = min(glassBase, belt);
	dist = min(dist, glassBase);

	dist = min(dist, sdSphere(glassPoint + vec3(0.0, 0.0, .35), .55));

	float mouth = sdEllipsoid(opCheapBend(point, .25) - vec3(0.8, 1.5, 1.15), vec3(.4, .1, 1.0));

	dist = max(dist, -mouth);

	return dist;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

float random(inout uint seed)
{
	seed = hash(seed);
	return floatConstruct(seed);
}

vec2 hash2( vec2 p ) 
{
    const vec2 k = vec2( 0.3183099, 0.23678794 );
    p = p*k + k.yx;
    return fract( 13.0 * k * fract(p.x*p.y*(p.x+p.y)));
}

// iq
mat3x3 rotationAxisAngle( const vec3 v, float a )
{
    const float si = sin( a );
    const float co = cos( a );
    const float ic = 1.0f - co;

    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,
                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,
                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );
}

float randomCubes(vec3 p)
{
	float d = 1000.0;

	uint seed = 14041956 + 34534;

	for(int i = 0; i < 32; i++)
	{
		vec3 offset = vec3(random(seed), random(seed), random(seed)) - .5;
		vec3 size = vec3(random(seed), random(seed), random(seed)) * .2;
		mat3x3 rot = rotationAxisAngle(normalize(vec3(random(seed), random(seed), random(seed))), random(seed) * 3.14);
		p = rot * p;
		d = min(d, fBox(p - offset, size));
	}	

	return d;
}

// Projected into 1D
float hash3D(vec3 x)
{
	float i = dot(x, vec3(123.4031, 46.5244876, 91.106168));
	return fract(sin(i * 7.13) * 268573.103291);
}

float fade1(float t)
{
	float t3 = t * t * t;
	return 6.0 * t3 * t * t - 15.0 * t3 * t + 10.0 * t3;
}

// We can use a hash as seed for a linear congruential generator
float lcg(float x)
{
	return mod(x * 25214903917.0 + 28411.0, 1306633.0) / 1306633.0;
}

vec3 gradient3D(vec3 x)
{
	float h = hash3D(x);
	float r1 = lcg(lcg(h));
	float r2 = lcg(lcg(r1));
	return normalize(vec3(h, r1, r2) * 2.0 - 1.0);
}

float perlin3D(vec3 p)
{
	// Z = 0
	vec3 p1 = floor(p);
	vec3 p2 = p1 + vec3(1.0, 0.0, 0.0);
	vec3 p3 = p1 + vec3(0.0, 1.0, 0.0);
	vec3 p4 = p1 + vec3(1.0, 1.0, 0.0);

	// Z = 1
	vec3 p5 = p1 + vec3(0.0, 0.0, 1.0);
	vec3 p6 = p1 + vec3(1.0, 0.0, 1.0);
	vec3 p7 = p1 + vec3(0.0, 1.0, 1.0);
	vec3 p8 = p1 + vec3(1.0, 1.0, 1.0);

	// Gradient directions
	vec3 gd1 = gradient3D(p1);
	vec3 gd2 = gradient3D(p2);
	vec3 gd3 = gradient3D(p3);
	vec3 gd4 = gradient3D(p4);

	vec3 gd5 = gradient3D(p5);
	vec3 gd6 = gradient3D(p6);
	vec3 gd7 = gradient3D(p7);
	vec3 gd8 = gradient3D(p8);

	// Directions
	vec3 d1 = p - p1;
	vec3 d2 = p - p2;
	vec3 d3 = p - p3;
	vec3 d4 = p - p4;

	vec3 d5 = p - p5;
	vec3 d6 = p - p6;
	vec3 d7 = p - p7;
	vec3 d8 = p - p8;

	// Interpolation remapping
	float fX = fade1(p.x - p1.x);
	float fY = fade1(p.y - p1.y);
	float fZ = fade1(p.z - p1.z);

	// Influences
	float i1 = dot(d1, gd1);
	float i2 = dot(d2, gd2);
	float i3 = dot(d3, gd3);
	float i4 = dot(d4, gd4);

	float i5 = dot(d5, gd5);
	float i6 = dot(d6, gd6);
	float i7 = dot(d7, gd7);
	float i8 = dot(d8, gd8);

	// Trilinear
	// Z = 0
	// p3 ------------- p4
	// |               |
	// p1 ------------- p2
	//         x
	// Z = 1
	// p7 ------------- p8
	// |                |
	// p5 ------------- p6	
	float m1 = mix(mix(i1, i2, fX), mix(i3, i4, fX), fY);
	float m2 = mix(mix(i5, i6, fX), mix(i7, i8, fX), fY);

	return mix(m1, m2, fZ) * 0.707213578 + .5;
}

// Refer to original curl paper
vec3 curl3D(vec3 p, float epsilon)
{
	vec2 eps = vec2(epsilon, 0.0);

	// N1: noise(p);
	// N2: noise(p + offsetN2);
	// N3: noise(p + offsetN3);
	vec3 offsetN2 = vec3(27.0, 13.0, 41.0);
	vec3 offsetN3 = vec3(35.0, 85.0, -30.0);

	float dN1dy = perlin3D(p + eps.yxy) - perlin3D(p - eps.yxy);
	float dN1dz = perlin3D(p + eps.yyx) - perlin3D(p - eps.yyx);

	float dN2dx = perlin3D(p + eps.xyy + offsetN2) - perlin3D(p - eps.xyy + offsetN2);
	float dN2dz = perlin3D(p + eps.yyx + offsetN2) - perlin3D(p - eps.yyx + offsetN2);

	float dN3dx = perlin3D(p + eps.xyy + offsetN3) - perlin3D(p - eps.xyy + offsetN3);
	float dN3dy = perlin3D(p + eps.yxy + offsetN3) - perlin3D(p - eps.yxy + offsetN3);

	return vec3(dN3dy - dN2dz, dN1dz - dN3dx, dN2dx - dN1dy) / epsilon;
}

float randomSpheres(vec3 p)
{
	float d = 1000.0;

	uint seed = 14041956 + 34534;

	for(int i = 0; i < 32; i++)
	{
		vec3 offset = vec3(random(seed), random(seed), random(seed)) - .5;
		vec3 size = vec3(random(seed), random(seed), random(seed)) * .2;
		mat3x3 rot = rotationAxisAngle(normalize(vec3(random(seed), random(seed), random(seed))), random(seed) * 3.14);
		p = rot * p;
		float radius = mix(.05, .3, random(seed));
		d = min(d, length(p + offset) - radius);
	}	

	return d;
}

// Reference: http://www.iquilezles.org/www/articles/triangledistance/triangledistance.htm
float udTriangleSquared(in TriangleData t, in vec3 p) {

	vec3 center = (t.v1 + t.v2 + t.v3) * .333;
	float size = max(length(center - t.v1), max(length(center - t.v2), length(center - t.v3)));

	float signed = -sign(dot(t.normal.xyz, p - center));

	//if(length(p - center) > size)
	//	return signed * (length(p-center) - size);

	vec3 p1 = p - t.v1;
    vec3 p2 = p - t.v2;
    vec3 p3 = p - t.v3;

	float insideFace = sign(dot(t.t21, p1)) + sign(dot(t.t32, p2)) + sign(dot(t.t13, p3));
	float faceDistance = pow(dot(t.normal.xyz, p1), 2.0) * t.normal.w;
	
	float edgeDistance = min(min(
                  dot2(t.v21.xyz * saturate(dot(t.v21.xyz, p1) * t.v21.w) - p1), 
                  dot2(t.v32.xyz * saturate(dot(t.v32.xyz, p2) * t.v32.w) - p2)), 
                  dot2(t.v13.xyz * saturate(dot(t.v13.xyz, p3) * t.v13.w) - p3));

    //return (insideFace < 2.0) ? edgeDistance : signed * faceDistance;
	return mix(signed * faceDistance, edgeDistance, step(insideFace, 2.0));
}

struct StackData
{
	int nodeOffset;
	float minDistance;
	float maxDistance;
};

float generateMeshSDF(vec3 p)
{
	float minDistance = 50000.0;
	
	StackData stack[64];
	int stackTop = 0;
	int currentNode = 0;

	//float currentDistance = 1000000.0;

	// The stack approach is very similar to pbrtv3
	while (currentNode != -1 && stackTop < 64)
	{
		//// If on a previous loop there was an intersection and is closer
		//// than the current node min distance, don't even start checking intersections
		//if (currentDistance < minDistance)
		//	break;

		TreeNode cNode = indexData[currentNode];
		int leftNode = cNode.leftNode;
		int rightNode = cNode.rightNode;
		float split = cNode.split;
		int axis = cNode.axis;

		// Leaf
		if (leftNode == -1 && rightNode == -1)
		{
			int primitiveCount = cNode.primitiveCount;
			int triangleOffset = cNode.primitiveStartOffset;
			
			// Check intersection with all primitives inside this node
			for (int i = 0; i < primitiveCount; i++)
			{
				TriangleData triangle = data[triangleOffset + i];
				float triangleDistance = udTriangleSquared(triangle, p);

				if(abs(triangleDistance) < abs(minDistance))
					minDistance = triangleDistance;
			}

			if(primitiveCount > 0)
			{
				// Because of the nature of our iteration,
				// if we are in a leaf, we are sure we found something
				break;
			}
			else if (stackTop > 0)
			{
				stackTop--;
				currentNode = stack[stackTop].nodeOffset;
			}
			else break; // There's no other object in the stack, we finished iterating!
		}
		else
		{
			int nearNode = leftNode;
			int farNode = rightNode;

			if (p[axis] >= split)
			{
				nearNode = rightNode;
				farNode = leftNode;
			}

			// We always check all children
			stack[stackTop].nodeOffset = farNode;
			stackTop++; // Increment the stack
			currentNode = nearNode;
		}
	}
	
	return sqrt(abs(minDistance)) * sign(minDistance) - .0015;
}

void main() {
	
    ivec3 coord = ivec3(gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID);
    vec3 nPos = (vec3(coord) / vec3(gl_WorkGroupSize * gl_NumWorkGroups)) * 2.0 - 1.0;

	//nPos.xz += sin(nPos.y * 14.0) * .1;
	//float sdf = length(nPos) - .45;// minionBaseSDF(nPos);//fBox(nPos, vec3(0.35));

	//sdf -= sin(nPos.y * 32.0) * .1;
	//sdf -= perlin3D(nPos * 8.0) * .02;
	//nPos += perlin3D(nPos * 4.0) * .1;

	float sdf = randomSpheres(nPos);

	imageStore(VectorField, coord, vec4(curl3D(nPos * 3.0 + vec3(.123, .64, 5.0), .01), perlin3D(nPos * 5.0)));

	imageStore(MeshSDF, coord, vec4(sdf));
}