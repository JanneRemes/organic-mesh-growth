#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 8

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = WORKGROUP_SIZE) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

layout(set = 2, binding = 0, r32f) coherent uniform image3D SourceMeshSDF;
layout(set = 3, binding = 0, r32f) coherent uniform image3D TargetMeshSDF;

float sdf(ivec3 p) {
	return imageLoad(SourceMeshSDF, p).x;
}

vec3 sdfNormal(ivec3 pos, int offset)
{
	ivec2 eps = ivec2(offset, 0);

	float dx = sdf(pos + eps.xyy) - sdf(pos - eps.xyy);
	float dy = sdf(pos + eps.yxy) - sdf(pos - eps.yxy);
	float dz = sdf(pos + eps.yyx) - sdf(pos - eps.yyx);

	return normalize(vec3(dx, dy, dz));
}

float kernel(ivec3 x, vec3 dx, float sdf, vec3 normal) {
	float neighbor = imageLoad(SourceMeshSDF, x).x;
	float activation = clamp(1.0 - abs(smoothstep(0.0, .05, neighbor) - .5) / .5, 0.0, 1.0);

	if(activation > 0.0)
	{
		vec3 n = sdfNormal(x, 4);

		// We want to grow when the normals are different
		float NdotN = 1.0 - smoothstep(0.2, 0.45, dot(normal, n));
		dx = abs(dx);

		float manhattanDistance = pow((dx.x + dx.y + dx.z), 4.0);
		float curvatureGrowth = .05 * -NdotN * manhattanDistance;
		float borderGrowth = -(neighbor - sdf) * .35 * manhattanDistance;

		return activation * (curvatureGrowth + borderGrowth);
	}

	return 0.0;
}

float expansion(ivec3 x, vec3 dx, float sdf, vec3 normal) {
	float neighbor = imageLoad(SourceMeshSDF, x).x;
	float activation = clamp(1.0 - abs(smoothstep(0.0, .05, neighbor) - .5) / .5, 0.0, 1.0);

	return -neighbor * 20.0;
}

float relaxation(ivec3 x, vec3 dx, float sdf, vec3 normal) {
	float neighbor = imageLoad(SourceMeshSDF, x).x;
	float activation = clamp(1.0 - abs(smoothstep(0.0, .05, neighbor) - .5) / .5, 0.0, 1.0);

	return neighbor * 80.0;
}

void main() {
	
    ivec3 coord = ivec3(gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID);

	int kernelHalfSize = 1;
	ivec3 minBounds = clamp(coord - kernelHalfSize, ivec3(0), ivec3(255));
	ivec3 maxBounds = clamp(coord + kernelHalfSize, ivec3(0), ivec3(255));

	float oldValue = imageLoad(SourceMeshSDF, coord).x;
	vec3 normal = sdfNormal(coord, 1);

	float value = 0.0;
	float count = 0.0;
	for (int k = minBounds.z; k <= maxBounds.z; ++k) {
		for (int j = minBounds.y; j <= maxBounds.y; ++j) {
			for (int i = minBounds.x; i <= maxBounds.x; ++i) {
				ivec3 x = ivec3(i,j,k);
				//value += kernel(x, vec3(x - coord) / float(kernelHalfSize), oldValue, normal);
				//value += relaxation(x, vec3(x - coord) / float(kernelHalfSize), oldValue, normal) * .0025;
				value += -.2;
				++count;
			}
		}
	}
	value /= count;

	//vec3 nPos = vec3(coord / 256.0) * 12.0;
	//vec3 dir = vec3(cos(nPos.x), -(sin(nPos.y) * .5 + .5), cos(nPos.z));
	//value += -max(0.0, dot(normal, dir)) * .05;

	// The growth kernel is relative to its current value
	float newValue = mix(oldValue, oldValue + value, min(1.0, deltaTime * .1));

	imageStore(TargetMeshSDF, coord, vec4(newValue));
}